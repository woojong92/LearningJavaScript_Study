# 표현식과 연산자 #


## 표현식 ##

- 표현식(expression)은 값으로 평가될 수 있는 문.

- 표현식이 아닌 문(statement)은 일종의 지시

	- ”당신이 할 일 은 볼트 A를 너트 B에 끼우는 일입니다.” ->표현식x

- 표현식은 무언가를 요청하는 것

- ”볼트 A를 너트 B에 끼우고, 내가 검사할 수 있도록 가져오세요.” -> 표현식
- 지시를 받고 그 결과를 명시적으로 반환하는 것 -> 표현식은 갑이 된다.
- 표현식은 값이 되므로 할당에 쓰일 수 있다.
- 표현식은 대부분 연산자표현식이다.
- 식별자 표현식(변수와 상수 이름)과 리터럴 표현식 

## 연산자 ##
- 표현식이 값이 되는 것이라면 연산자는 값을 만드는 행동

### 산술 연산자 ###


> 자바스크립트이 숫자는 모두 더불 형식
- 연산자 우선순위
- 비교 연산자
- loose equality : ==, !=
- String equality : ===, !==
-  관계 연산자 : >, <, >=, <= 

### 숫자비교 ###
- 먼저, 특별한 숫자형 값 NaN은 그 자신을 포함하여 무엇과도 같지 안다.
- NaN === NaN : false , NaN == NaN : false
- isNaN 내장함수를 사용하여 숫자가 NaN인지 확인
- isNaN(x) -> x가 NaN이면 true 반환, x가 NaN이 아니면 false 반환

- 자바스크립트의 숫자는 모두 더블 형식
- 소수점이 있는 숫자를 비교할 때는 ‘충분히 가까운지’ 확인하는 게 좋음.
- 자바스크립트의 특별한 상수형(Number.EPSILON)은 매우 작은 값(약 2.22e-16)이다.

		
		let n =0;
		while(true) {
			n += 0.1;
			if(n === 0.3) break;
		}
		console.log(‘stopped at ${n}’);
		
 - 0.1은 더블 형식으로 정확히 나타낼 수 없는 값. 


		let n =0;
		while(true) {
			n += 0.1;
			if( Math.abs(n-0.3) < Number.EPSLION) break;
		}
		console.log(‘stopped at ${n}’);
		

### typeof 연산자 ###

- typeof 연산자는 피연산자의 타입을 나타내는 문자열을 반환.
- 자바스크립트의 일곱 가지 데이터 타입(undefine, null, 불리언, 숫자, 문자열, 심볼, 객체)를 정확하게 나타내지 못해 끝없는 혼란을 초래했고 비판 받음.
- typeof null -> “object”반환
- 배열과 배열 아닌 객체도 정확히 구분하지 못함.
- typeof [] -> “object”반환

> cf. ch05, 159pages

### 해체 할당 ###
- ES6에 새로 도입한 해체 할당(destructuring assignment)
- 객체나 배열을 변수로 ‘해체’할 수 있다.


### 객체 해체 ###
 
	//객체 선언
	const obj = { b: 2, c: 3, d: 4};
	
	//해체 할당
	const {a, b, c} = obj;	//선언과 할당을 같은 문에서 실행
	a;	//undefined: obj에는 “a” 프로퍼티가 없습니다.
	b;	//2	
	c;	//3
	d;	//ReferenceError: “d”는 정의되지 않았습니다.
	‘’’
		객체를 해체할 때는 반드시 변수 이름과 객체의 프로퍼티 이름이 일치해야 한다.
		프로퍼티 이름이 유효한 식별자인 프로퍼티만 해체 후 할ㅏㅇ됩니다.
	
	‘’’
	const obj = { b: 2, c: 3, d: 4};
	let a, b, c;
	{a, b, c} = obj;	//에러 발생
	({a, b, c}) = obj;	//동작함


- 객체 해체는 할당만으로 이뤄질 수도 있지만, 반드시 괄호를 써야함, 쓰지 않으면 자바스크립트는 표현식 좌변을 블록으로 해석

- 배열을 해체할 때는 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 이들은 배열 순서도래 대응한다.

		const arr =[1, 2, 3];

		//배열 해체 할당
		let [x ,y] = arr;
		x;	//1
		y;	//2
		z;	//ReferenceErroer: “z”는 정의되지 않았습니다.
	
- 확산 연산자Spread operator(…)를 사용하면 남은 요소를 새 배열에 할당 할 수 있다.

		const arr = [ 1, 2, 3, 4, 5];
		
		//배열 해체 할당
		let [x ,y …rest] = arr;
		x;	//1
		y;	//2
		rest;	//[3, 4, 5]


