# 객체와 객체지향 프로그램 #

배열과 마찬가지로 자바스크립트 객체 역시 컨테이너지만, 크게 보면 두 가지 측면에서 배열과 다르다.

- 배열은 값을 가지며 각 값에는 숫자형 인덱스가 있다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있다.
- 배열에는 순서가 있다. 반면, 객체에는 그런 순서가 보장되지 않는다.
- 프로퍼티는 키 (문자열 또는 심볼)과 값으로 구성, 객체의 진짜 특징은 키를 통해 프로퍼티에 접근 할 수 있다는 점이다.

## 프로퍼티 나열 ##

- 프로퍼티 나열은 순서가 보장되지 않는다.
- 객체 프로퍼티에는 순서가 없다.

### for...in ###
		
		const SYM = Symbol();
		
		const o = { a: 1. b: 2. c: 3, [SYM]: 4};
		
		for(let prop in o) {
			if(!o.hasOwnProperty(prop) continue;
			console.log('${prop}: ${o[prop]}');
		}

- hasOwnProperty는 상속된 프로퍼티가 for...in에 나타날 위험을 제거하기 위해 사용한다.
- 다른 타입의 객체, 특히 다른 사람이 만든 객체의 프로퍼티를 나열하다 보면 예상치 못한 상황이 생길 수 있으므로 hasOwnProperty를 쓰는 습관을 들이는 걸 권장한다.

- for...in루프에는 키가 심볼인 프로퍼티는 포함되지 않는다.

> for_in을 배열에 사용할 수도 있겠지만, 그리 좋은 생각은 아니다. 배열에는 일반적인 for루프나 forEach를 사용해라.

### Objcet.keys ###

- Object.keys는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환한다.

		const SYM = Symbol();
		
		const o = { a: 1. b: 2. c: 3, [SYM]: 4};

		Object.keys(o).forEach(prob => console.log('${prop}:${o[prop]}'));

- 위 예제는 for...in 루프를 썼을 때와 같은 결과이고 hasOwnProperty를 체크할 피요가 없다. 
- 객체의 프로퍼티 키를 배열로 가져와 할 때는 Object.keys가 편리하다.
- 예를 들어 객체에서 x로 시작하는 프로퍼티를 모두 가져온다면 다음과 같은걸 할 수 있다:
		
		const o = { apple: 1, xochitl: 2, balloon: 3, guitar: 4, xylophone: 5, };
		
		Object.keys(o)
			.filter(prop => prop.match(/^x/))
			.forEach(prop => console.log('${prop}: ${o[prop]}'));

## 객체지향 프로그래밍 ##

- 객체는 데이터와 기능을 논리적으로 묶어 놓은 것
- 클래스는 어떤 자동차처럼 추상적이고 범용적인 것
- 인스턴스는 특정 자동차처럼 구체적이고 한정적인 것
- 기능은 메서드라 부른다.
- 클래스에 속하지만 특정 인스턴스에 묶이지는 않는 기능을 클래스 메서드라고 한다.
- 인스턴스를 처음 만들 때는 생성자가 실행되고, 생성자는 객체 인스턴스를 초기화한다.

### 클래스와 인스턴스 생성 ###